<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" applicationComplete="startup()" backgroundColor="#000000" verticalScrollPolicy="off" horizontalScrollPolicy="off" >
	<mx:Style source="main.css"/>
	<mx:Script>
		<![CDATA[
			import com.adobe.serialization.json.*;
			import com.constellation.Watermark;
			import com.constellation.config.errorConfig;
			import com.constellation.controllers.heartbeatController;
			import com.constellation.events.NetEvent;
			import com.constellation.events.constellationEvent;
			import com.constellation.externalConfig.ExternalConfig;
			import com.constellation.managers.loggingManager;
			import com.constellation.net.FMSConnection;
			import com.constellation.net.FMSStream;
			import com.constellation.net.MBR.mbrManager;
			import com.constellation.parsers.smilParser;
			import com.sierrastarstudio.utils.tracer;
			import com.zeusprod.AEScrypto;
			import com.zeusprod.LoadExternalSwf;
			
			import flash.net.navigateToURL;
			
			import org.casalib.load.DataLoad;
			import org.casalib.util.NavigateUtil;
			/**
			 * Are we running a heart beat?<br>
			 *  Call out to heartbeat URL<br>
			 * 			hearbeat returns JSON format :  {'result':(boolean),'message':(string)}<br>
			 * 	<br> 
			 *	We check and act as needed
			 * */ 
			//what's the name of the class to easier ID it
			private var _classname:String="main";
			
			private var CONTROLBAR_HEIGHT:int = 50;
			
			private var _heartbeating:Boolean = true;
			// The viewer of the hostcam
			private var liveViewerSwf:LoadExternalSwf; 
			
			// Version Number
			private static var version:String = "25";
			
			// Are we in testing mode?
			private var _testLocal:Boolean;
			
			private var testTimer:Timer = new Timer(2000);
			
			// Video width and height
			// This is the default "large size"
			private var videoWidth:Number = 1280;
			private var videoHeight:Number = 720; 
			
			// NetStream
			private var inStream:NetStream;
			
			// Reference RTMP
			private var nc:NetConnection;
			
			// Normal RTMP
			private var normalNC:NetConnection;
			
			// Tunnel RTMPT
			private var altNC:NetConnection;
			
			// The video object
			private var remoteVideo:Video;
			
			// Detect that we are done with one connection
			private var alreadyConnected:Boolean = false;
			
			// Detect that we are already playing
			private var alreadyPlaying:Boolean = false;
			
			// Hostname
			private var hostName:String = "cp113558.edgefcs.net";
			
			// Token
			private var token:String;
			
			// Server IP Information - Problematic Proxies
			private var serverIP:String;
			//nc.connect("rtmp://"+serverIP+"/ondemand?_fcs_vhost="+hostName);
			
			// This is the number of the video file from the directory
			// It will come from slist flashvar
			private var streamNumber:Number = 15;
			
			// Default slist var using streamNumber
			private var slist:String; //="constellation/movies/" + streamNumber + "/movie-large;constellation/movies/" + streamNumber + "/movie-medium;constellation/movies/" + streamNumber + "/movie-small";
			
			// Default streamName using streamNumber
			private var streamName:String; // ="constellation/movies/" + streamNumber + "/movie-small";
			
			// The string for requesting from Akamai
			private var playString:String; // = "mp4" + ":" + streamName;
			
			// Token Requests
			private var tokenUrlLoader:URLLoader;
			private var tokenUrlRequest:URLRequest;
			
			// Akamai ident Requests
			private var identUrlLoader:URLLoader;
			private var identUrlRequest:URLRequest;
			
			// Adjustable Parameters and Constants
			
			// The amount to rewind when switching bitrates
			private static var SEEKREWINDSECONDS:Number = 0;
			
			// Should we do a bandwidth check on connect?
			private static var CHECKBANDWIDTH:Boolean = true;
			// Are we on the first or later bandwidth check
			private var laterCheckBandwidth:Boolean = false;

			// Initial buffer time to get things started
			private static var LOADINGBUFFERTIME:Number = .5; // in seconds
			// After initial buffer is full, switch to this
			private static var PLAYINGINGBUFFERTIME:Number = 30; // In seconds 
			
			// Keeping track of number of buffer emptys
			private var bufferEmptyCount = 0;
			// The amount allowed
			private static var BUFFEREMPTYCOUNTTHRESHOLD = 2;
			
			// The number of buffer low 
			private var bufferLowCount = 0;
			// The number allowed before taking action
			private static var BUFFERLOWCOUNTTHRESHOLD = 5;
			
			// The number of buffer highs
			private var bufferHighCount = 0;
			// The number allowed before taking action
			private static var BUFFERHIGHCOUNTTHRESHOLD = 15;
			
			// Number FPS zeros
			private var fpsZeroCount = 0;
			// THe number allowed
			private static var FPSZEROCOUNTTHRESHOLD = 2;
			
			// Last buffer length in stream check
			private var lastBufferLength = 0;
			
			// Current stream size - 0 is low
			private var currentStreamSize = 0;
			// The highest stream size ..  2 is high
			private  var MAXSTREAMSIZE:int; //let the smil tell us how many streams there are
			
			// Timer for checking the stream
			private static var STREAMCHECKTIMERINTERVAL = 5000; // milliseconds
			private var streamCheckTimer:Timer = new Timer(STREAMCHECKTIMERINTERVAL);
			
			// Currently switching streams
			private var currentlySwitching = false;
			
			// Timer for mouse movements, display fullscreen button
			private var mouseMoveTimer:Timer;// = new Timer(2500);
			
			// Flashvars
			private var flashvars:Object;
			private var seekInto:Number = 0; // Being used, how far into the video when playing
		
			private var ticketParams:String; // Being used, passed back to get token
			
		//	private var fileType:String = "mp4"; // Or a MOV?
		//	private var bitrate:String = "600,1600,2400"; // bitrate
			
			// The parsed bandwidth settings
			private var largeBandwidth = 2400; // 100 kbps higher than the encoded values
			private var mediumBandwidth = 1600;
			private var smallBandwidth = 600;
			private static var EXTRABANDWIDTHREQUIRED = 100 + 300; // How much to add + hostcam
			
			// For displaying messages
			private static var MESSAGETIMERTIME = 15000; // Milliseconds
			private var messageTimer:Timer;
						
			// For keeping track of play position
			private var lastInStreamTime:Number = 0;
			
			private var streamComplete:Boolean = false;
			/**
			 * heartbeat controller takes care of dealing with the heartbeat
			 * 
			 * @param The Path to the heartbeat url
			 */ 			
			private var _heartbeatController:heartbeatController;
			
			private var _smilParser:smilParser;
		
			// First thing to run, step 1
			private var _hmac:Object;
			private var _originalTicketParam:String;
			
			public static var HIGH_STREAM:uint =2;
			public static var MEDIUM_STREAM:uint =1;
			public static var LOW_STREAM:uint =0;
			//encoded string to prepData to send to service for auth			
			private var _prepData:String;
			
			private var _dataPostStr:String;
			private var _timeStampTimer:Timer;
			private var _timeStampServer:int;
			private var TIMESTAMP_INTERVAL:int = 1;

			
			
			private function startup():void
			{
				Security.allowDomain("*.constellation.tv");
				debug("startup version: " + version);
				// Add some listeners
				//stage.addEventListener(Event.FULLSCREEN,sizeChanged);
				stage.addEventListener(Event.RESIZE, resizeHandler); 				
				stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
				
				//load up the external config
				ExternalConfig.getInstance().loadOptions(this);
				this._testLocal = ExternalConfig.getInstance().testLocal;
				
				this._timeStampTimer = new Timer(TIMESTAMP_INTERVAL);
				this._timeStampTimer.addEventListener(TimerEvent.TIMER,onIncrementTimeStamp);
			//	tracer.log("timestamp passed in "+ExternalConfig.getInstance().initTimeStamp,_classname);
				
			try{
				// Get flashvars
				flashvars = this.parameters;
					// ticketParams
					
					/*lets try not to break anything major until we can get some refactoring on all of this
					* AES Encrypted : ticket(string)|film(int)|hmac(string)|timestamp(int)
					*	TESTING values:
					*		encrypted: j/7+EWGBSU41wvJcwPcwjlITYDm2w/gCoGEo
					*		decrypted: WjFpZI|4|wtHjbIS7ij
					*/
					//if(this._testLocal==true){
						ticketParams = ExternalConfig.getInstance().ticketParams;
					//}
					this._originalTicketParam = ticketParams;
					
				
					ticketParams = replaceSpacesWithPlus(ticketParams)
					var decryptedTicketParam:String = AEScrypto.decrypt(ticketParams);
				
					var newTicketParam:String = decryptedTicketParam.split(AEScrypto.DELIMITER)[0];
					
					this.ticketParams = newTicketParam;
					ExternalConfig.getInstance().ticketDecrypted = this.ticketParams;
					
					var newFilmNumber:int = int(decryptedTicketParam.split(AEScrypto.DELIMITER)[1]);
					
					this.streamNumber = newFilmNumber;
					
					var newHMAC:String = decryptedTicketParam.split(AEScrypto.DELIMITER)[2];
					
					this._hmac = newHMAC;
				//log that the user has valid decrypt ticket
					loggingManager.getInstance().loadLoggingPath();
					loggingManager.getInstance().logToServer("User has valid ticket : Attempting Token");
					
					
					// seekInto
						seekInto = ExternalConfig.getInstance().seekInto;
					
						lastInStreamTime = seekInto;
				
						// Get the token
				tokenUrlLoader = new URLLoader();
		 
				//tokenUrlRequest = new URLRequest("/services/Tokenizer/init?k=" + streamNumber);	
				//create the time stamp timer
			
				if(!isNaN(ExternalConfig.getInstance().initTimeStamp)){
					this._timeStampServer = ExternalConfig.getInstance().initTimeStamp;
					this._timeStampTimer.start();
				}
				
				this._dataPostStr = this.ticketParams+AEScrypto.DELIMITER+this.streamNumber+AEScrypto.DELIMITER+this._hmac+AEScrypto.DELIMITER+this._timeStampServer
			//	tracer.log("********************  new encrypt string "+this._dataPostStr,_classname);
				var encryptDataPost:String = AEScrypto.encrypt(this._dataPostStr);
				var postData:URLVariables = new URLVariables();
					//postData.k = ticketParams;
				this._prepData = AEScrypto.reencrypt(encryptDataPost);
				
					postData.k = encryptDataPost;//this._prepData;
				
				/*	if(this._testLocal==true){
						// For testing
						var serverTest:String = "/services/Tokenizer/"+this.streamNumber+"/map.smil?k=" + this._prepData;
						var localTest:String = ExternalConfig.getInstance().smilTestPath
						tokenUrlRequest = new URLRequest(serverTest);	
						
					}else{
						/* NOT TESTING */
						tokenUrlRequest = new URLRequest("/services/Tokenizer/"+this.streamNumber+"/map.smil?k=" + encryptDataPost);//this._prepData);
					//}
				tokenUrlRequest.method = URLRequestMethod.POST;	
				//tokenUrlRequest.contentType = "application/xhtml+xml"
				tokenUrlRequest.data = postData;
				
				//debug("Hitting: " + tokenUrlRequest.url);
				//debug("With: " + tokenUrlRequest.data);
				/* NOT TESTING */
				tokenUrlLoader.addEventListener(Event.COMPLETE, tokenUrlLoaderComplete);
				tokenUrlLoader.addEventListener(IOErrorEvent.IO_ERROR,onTokenHTTPError);
				if(this._testLocal==false){
					tokenUrlLoader.load(tokenUrlRequest);
				}
			}catch(err:Error){
				this.displayMessage(ExternalConfig.getInstance().defaultErrorMessage+errorConfig.init_Error,false)
			}
				// JavaScript, External Interface
					this.initExternalInterface();
						this.init();		
			}
			private function init():void{
				//check if we need heartbeat
				if(this._heartbeating==true){
					this._heartbeatController = new heartbeatController()
					this._heartbeatController.addEventListener(constellationEvent.HEART_ATTACK,onHeartAttack);
					
				}
				//place the fullscreen image
				fullscreenImage.x = 10;
				fullscreenImage.y = stage.stageHeight - fullscreenImage.height -CONTROLBAR_HEIGHT;
				fullscreenImage.visible = false;
				Security.allowDomain("*.constellation.tv");
				
				//create the smil parser and listen for smil parsed event
				this._smilParser = new smilParser();
				this._smilParser.addEventListener(constellationEvent.SMIL_PARSED,onSmilParsed);
				this._smilParser.addEventListener(constellationEvent.SMIL_MALFORMED,onSMIL_Malformed);
				if (this._testLocal ==true) {
					this._smilParser.loadSMILDirect( "../data/elephants_dream.smil")
				}
				Watermark.init(this.stage,1000);
				Watermark.startup( _originalTicketParam );
				Watermark.startTimer();
				
				// Setup Timers
				if (this._testLocal ==true) {
					testTimer.addEventListener(TimerEvent.TIMER,testTimerFired);
					testTimer.start();
				}
				
				//streamCheckTimer.addEventListener(TimerEvent.TIMER,streamCheckTimerFired);
				//create instance of mbrManager and listen for events
				mbrManager.getInstance().addEventListener(constellationEvent.STREAM_NOTIFY,onMBRStreamNotify);
				
			}
			protected function onMBRStreamNotify(evt:constellationEvent):void
			{
			tracer.log("stream notified from MBR "+evt.data,_classname);
			//	this.swapStream(int(evt.data));
			}
			private function setupDebugTools():void{
				//debugConsole
				
				/*if (TESTING || (flashvars.debugConsole != null && flashvars.debugConsole == "true")) {
				// Should add the other related buttons and such in here
				debug("in testing mode");
				debugButton.visible = true;
				smallstream.visible = true;
				mediumstream.visible = true;
				largestream.visible = true;
				stopstream.visible = true;
				} else {
				debug("not in testing mode");
				debugButton.visible = false;
				smallstream.visible = false;
				mediumstream.visible = false;
				largestream.visible = false;
				stopstream.visible = false;
				}
				*/
			}
			public function textMessagEvent(evt:TextEvent):void{
				var messageEvent:String = evt.text.toLowerCase();
				
				trace("Event "+evt.text);
				if(messageEvent=="supportemail"){
					//navigateToURL(new URLRequest("mailto:support@constellation.tv?subject=Constellation.tv Screening Error "+this._currentErrorCode), "_self");
					NavigateUtil.openWindow("mailto:support@constellation.tv?subject=Constellation.tv Screening Error "+this._currentErrorCode,NavigateUtil.WINDOW_BLANK);
				}
			}
			protected function onTokenHTTPError(event:Event):void
			{
			//had an error getting auth and token
				this._currentErrorCode = errorConfig.auth_tokenHTTPErrorCode;
				this.displayMessage(ExternalConfig.getInstance().defaultErrorMessage+errorConfig.auth_tokenHTTPErrorCode,false);
				loggingManager.getInstance().logToServer("HTTP error getting token");
			}
			
			// From JavaScript
			public function setVolume(theVolume:Number):void {
				//ExternalInterface.call("alert(\"running setVolume\")");
				debug("Setting Volume " + theVolume);
				
				var volumeTransform:SoundTransform = new SoundTransform();
				volumeTransform.volume = theVolume/10;
				if (inStream != null) {
					inStream.soundTransform = volumeTransform;
				}
			}
			
			// Token Loaded, this is step 2
			private function tokenUrlLoaderComplete(evt:Event):void 
			{
				
			try{
				if(	this._timeStampTimer.running==true){
					this._timeStampTimer.stop();
				}
						var loadedData:XML = new XML(evt.currentTarget.data);
						
						if(loadedData.toXMLString()=="unauth"){
							this._currentErrorCode = errorConfig.auth_authorizeError
							if (this._testLocal ==true) {
								this.displayMessage("unauth user ticketParam: "+this._originalTicketParam+"\nk: "+this._prepData+"\ndecrypted info "+this._dataPostStr,false);
							}else{
								this.displayMessage(ExternalConfig.getInstance().defaultErrorMessage+errorConfig.auth_authorizeError,false)
							}
							loggingManager.getInstance().logToServer("Token server returned UNAUTH");
						}
						this._smilParser.smilData = loadedData as XML;
			}catch(err:Error){
						this._currentErrorCode = errorConfig.auth_authorizeError
					
						if (this._testLocal ==true) {
							this.displayMessage("unauth user ticketParam: "+this._originalTicketParam+"\nk: "+this._prepData+"\ndecrypted info "+this._dataPostStr,false);
						}else{
							this.displayMessage(ExternalConfig.getInstance().defaultErrorMessage+errorConfig.auth_authorizeError,false)
						}
						loggingManager.getInstance().logToServer("Token server returned Error in parsing - XML formatting Error");
					}
				
		
			}
			private function onSmilParsed(constEvt:constellationEvent):void{
				this.doConnection();
			}
			
			// Step 3
			// Get ident server from Akamai
			private function getIdent():void
			{
				debug("getIdent");
				
				identUrlRequest = new URLRequest("http://"+hostName+"/fcs/ident");
				debug("making request to: http://" + hostName + "/fcs/ident");
				identUrlLoader = new URLLoader();
				identUrlLoader.addEventListener(Event.COMPLETE, identUrlLoadComplete);
				identUrlLoader.load(identUrlRequest);
			}
			
			// Got ident server, step 4
			private function identUrlLoadComplete(e:Event):void 
			{
				
				debug("identUrlLoaded");
				/*
				<?xml version="1.0" encoding="utf-8" ?>
				<fcs><ip>208.22.87.127</ip></fcs>
				*/
				debug(e.target.data);
				
				var identXML:XML = new XML(e.target.data);
				serverIP = identXML.ip.text()[0];
				debug("serverIP is " + serverIP);
				
				// Go to step 5
				doConnection();
			}
			
			// Step 5, do the actual connections
			private function doConnection():void
			{
				loggingManager.getInstance().logToServer("attempting to connect to FMS");
			if(this._testLocal==false){
				this._heartbeatController.startHeartBeat();
			}
				debug("doConnection");
				
				normalNC = new NetConnection();
				normalNC.client = this;
				normalNC.addEventListener(NetStatusEvent.NET_STATUS,ncStatus);
				normalNC.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				normalNC.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onAsyncError);
				var hostName:String = this._smilParser.hostName;
				var protocol:String = this._smilParser.protocol;
				var SMILstreamName:String = this._smilParser.dsi.streams[0].name;
				var streamURL:String = protocol+"://"+hostName+"/"+SMILstreamName;
								// Explicitly not checking bandwidth here as it leads to too many callbacks
			//	if (serverIP != null) {
					//nc.connect("rtmp://"+serverIP+"/ondemand?_fcs_vhost="+hostName);
				//	normalNC.connect("rtmp://" + serverIP + "/ondemand/" + "mp4" + ":" + streamName + "." + fileType + "?_fcs_vhost=" + hostName + "&auth=" + token + "&aifp=v0001&slist=" + slist, false);
					normalNC.connect(streamURL);
					debug("connecting to " + normalNC.uri);
			/*	} else {
					normalNC.connect("rtmp://" + hostName + "/ondemand/" + "mp4" + ":" + streamName + "." + fileType + "?auth=" + token + "&aifp=v0001&slist=" + slist, false);
					debug("connecting to " + normalNC.uri);
				}
			*/
					debug("normalNC Connecting");
				
				// Tunnel Version
			/*	altNC = new NetConnection();
				altNC.client = this;
				altNC.addEventListener(NetStatusEvent.NET_STATUS,ncStatus);
				altNC.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				// Explicitly not checking bandwidth here as it leads to too many callbacks
				if (serverIP != null) {
					altNC.connect("rtmpt://" + serverIP + ":80/ondemand/" + "mp4" + ":" + streamName + "." + fileType + "?_fcs_vhost=" + hostName + "&auth=" + token + "&aifp=v0001&slist=" + slist, false);
					debug("connecting to " + altNC.uri);
				} else {
					altNC.connect("rtmpt://" + hostName + ":80/ondemand/" + "mp4" + ":" + streamName + "." + fileType + "?auth=" + token + "&aifp=v0001&slist=" + slist, false);
					debug("connecting to " + altNC.uri);
				}
				debug("altNC Connecting");
				*/
			}
			
			private function disconnectStream():void
			{
				
				if (nc.connected) {	
					nc.close();
				}
				
				alreadyConnected = false;
			}
		
			// Step 6, NetConnection results Connect.Success
			private function ncStatus(event:NetStatusEvent):void 
			{
				debug("ncStatus : "+event.info.code);
				
				switch (event.info.code) {
					case "NetConnection.Connect.Closed":
						debug("NET CONNECTION IS CLOSED");
						loggingManager.getInstance().logToServer("FMS connection CLOSED - attempting to reconnect");
						alreadyConnected = false
						this.doConnection();
					break;
					case "NetConnection.Connect.Success":
						
						if (!alreadyConnected) {
							
							// let's not run this again..
							alreadyConnected = true;
							
							if(streamCheckTimer.running==false){
							//only start the timer if one is not running
							//	streamCheckTimer.start();
							}
							if (event.currentTarget == normalNC) {
								debug("Normal NetConnection");
								
								if (altNC) { 
									altNC = null;
								}
								
								nc = normalNC;
								
							} else {
								
								debug("Alt NetConnection");
								
								if (normalNC) { 
									normalNC = null;
								}
								nc = altNC;
								
							}
							
							
							debug("Connected");
							loggingManager.getInstance().logToServer("Connected to FMS stream ");
						
							// If desired, do bandwidth check
							if (CHECKBANDWIDTH) {
								debug("Calling checkBandwidth");
								laterCheckBandwidth = false; // We are on the first one
								// This works phenominally better than the initial call when connecting.
								nc.call("checkBandwidth", null);
							} else {
								// If we aren't checking bandwidth, we'll just start the stream
								startStream();
							}								
						}
						
						break;
					
					case "NetConnection.Connect.NetworkChange":
						debug("Netconnection Network Change");
						/*
						if (!nc.connected) {
						alreadyConnected = false;
						doConnection();
						}
						*/
						break;
					
					case "NetStream.Play.StreamNotFound":
						debug("Stream not found");
						this._currentErrorCode = errorConfig.stream_streamNotFound;
						this.displayMessage(ExternalConfig.getInstance().defaultErrorMessage+this._currentErrorCode);
						loggingManager.getInstance().logToServer("FMS connection Stream name not found - disconnecting user");
						break;
					
					case "NetStream.Play.Transition":
						debug("Transition Event " +  event.info.reason);
						
						break;
					
					case "NetStream.Buffer.Full":
						debug("Buffer Full");
						/*
						if (inStream.bufferTime != PLAYINGINGBUFFERTIME) {
						inStream.bufferTime = PLAYINGINGBUFFERTIME;
						debug("Increased buffer to " + PLAYINGINGBUFFERTIME);
						} else {
						if (currentStreamSize < maxStreamSize) {
						debug("Increasing stream");
						swapStream(currentStreamSize+1);
						} else {
						debug("Already at largest stream");
						}
						}
						*/
						break;
					
					case "NetStream.Buffer.Empty":
						debug("Buffer Empty");
						if (!currentlySwitching) {
							bufferEmptyCount++;
							if (bufferEmptyCount >= BUFFEREMPTYCOUNTTHRESHOLD) {
								if (currentStreamSize > 0) {
									debug("Lowering stream");
									swapStream(currentStreamSize-1);
								} else {
									debug("Already at smallest stream");
								}
								bufferEmptyCount = 0;
							}
						}
						break;
					
					default:
						debug(event.info.code);
						
						break;
				}
			}
			
			// Not sure this is needed, server might tell us when it is doing it
			public function onBWCheck(... rest):Number { 
				debug("onBWCheck");
				return 0;
			} 
			
			// Step 7
			// This is called on the NetConnection client
			public function onBWDone(... rest):void { 
				debug("onBWDone Start");
				
				if (laterCheckBandwidth) {
					if (rest.length > 0) {
						// Pass this to other function
						laterOnBWDone(Number(rest[0]));
					}
				} else {
					
					if (rest.length > 0) {
						debug("bandwidth: " + rest[0] + " kbps");
						var bandwidth:Number = rest[0];
						
						// Should be specifying the stream to play here
						// Token needs to include these in the slist, movie-small, movie-medium
					var newIndex:int = 0;
						if (bandwidth > largeBandwidth) {
						newIndex = this._smilParser.dsi.streamCount-1
						} else if (bandwidth > mediumBandwidth) {
							newIndex = this._smilParser.dsi.streamCount-2
						
						} else if (bandwidth > smallBandwidth) {
							newIndex = this._smilParser.dsi.streamCount-3
						} else {
							//streamName="constellation/movies/" + streamNumber + "/movie-small";
							newIndex = this._smilParser.dsi.streamCount-(this._smilParser.dsi.streamCount-1);
							
							// Display not enough bandwidth message
							displayNotEnoughBandwidthMessage();
						}
						
						streamName = this._smilParser.dsi.streams[newIndex].name
						currentStreamSize = newIndex;
						mbrManager.getInstance().streamIndex = newIndex;
						// Go on to step 8, start stream
						debug("playing index "+newIndex+"  streamName" + streamName);
						//playString = "mp4" + ":" + streamName  + "." + fileType;
						playString = streamName;
						startStream();
					}
				}
				debug("onBWDone End");				
				
			} 	
			
			// This is called on the NetConnection client when we think we should switch
			public function laterOnBWDone(bandwidth:Number):void { 
				debug("laterOnBWDone Start");
				if (bandwidth > largeBandwidth && currentStreamSize < 2) {
				//	streamName="constellation/movies/" + streamNumber + "/movie-large";
					streamName = this._smilParser.dsi.streams[HIGH_STREAM].name
					debug("bandwidth good to go");
					swapStream(currentStreamSize+1);
				} else if (bandwidth > mediumBandwidth && currentStreamSize < 1) {
				//	streamName="constellation/movies/" + streamNumber + "/movie-medium";
					streamName = this._smilParser.dsi.streams[MEDIUM_STREAM].name
					currentStreamSize = MEDIUM_STREAM;
					debug("bandwidth good to go");
					swapStream(currentStreamSize+1);
				} else {
					debug("bandwidth not good enough to notch up: bandwidth: " + bandwidth + " largeBandwidth: " + largeBandwidth + " medium: " + mediumBandwidth + " current stream: " + currentStreamSize);
				}
				debug("laterOnBWDone End");				
			}
			
			// Messages to user
			public function displayNotEnoughBandwidthMessage():void {
				displayMessage("Your bandwidth seems low, you may encounter playback issues.");
			}
			
			public function displayBufferingMessage():void {
				displayMessage("Sorry - we're adjusting the stream based on your bandwidth.");
				//"Sorry - we're adjusting the stream based on your bandwidth." 
				
				/*
				- If we hit "0 FPS", or if we pause the player to do a file switch, we should show a timer/dial/rotating circle of some kind with a message, "Sorry - we're adjusting the stream based on your bandwidth."
				- If there is a pause because buffer hits 0, we should show the rotating dial with a message saying "Bandwidth low - please wait a moment while we adjust."  This second message should take priority over the first.
				*/
			}
			
			public function displayMessage(messageText:String,removeMessage:Boolean=true):void {
				messages.visible = true;
				messages.htmlText = "<br>"+messageText+"<br><br>";
				
				messages.x = (stage.width - messages.width)/2;
				messages.y = (stage.height - messages.height)/2;
				
				if (messageTimer == null || !messageTimer.running) {
					messageTimer = new Timer(MESSAGETIMERTIME,1);
					messageTimer.addEventListener(TimerEvent.TIMER,messageTimerFired);
					if(removeMessage==true){
						messageTimer.start();
					}
				} else {
						messageTimer.reset();
					if(removeMessage==true){
						messageTimer.start();
					}
				}
				messages.addEventListener(TextEvent.LINK,this.textMessagEvent);
			//	this.swapChildren(this.stage.getChildAt(this.numChildren-1),messages);
				
			}
			
			private function messageTimerFired(e:Event):void
			{
				debug("Message Timer Fired, Un-display Messages");
				messages.visible = false;		
			}
			
			public function dismissMessage():void {
				if (messages.visible == true) {
					messages.visible = false;
				}
			}
			
			// NetStream status messages
			public function onPlayStatus(info:Object):void { 
				switch (info.code) { 
					case "NetStream.Play.Complete": 
						debug("The stream has completed"); 
						streamComplete = true;
						break; 
					case "NetStream.Play.TransitionComplete":
						debug("The stream transition has completed");
						currentlySwitching = false;
						break;
					default:
						debug("Default: " + info.code);
						break;
				} 
			} 
			
			// This is on the NetStream client
			public function onCuePoint(infoObject:Object):void {
				debug("cuePoint");
			}
			
			// This is on the NetStream client
			public function onMetaData(infoObject:Object):void {
				debug("metaData");
				
				videoWidth = infoObject.width;
				videoHeight = infoObject.height;
				
				resizeVideo();
				
			}
			
			private function securityErrorHandler(event:SecurityErrorEvent):void {
				debug("securityErrorHandler: " + event);
				this._currentErrorCode = errorConfig.stream_securityError;
				this.displayMessage(ExternalConfig.getInstance().defaultErrorMessage+this._currentErrorCode,false);
			}

			// Change stream sizes
			private function swapStream(size:Number = 2):void {
				// Swapping process
				//tracer.log("SWITCHING STREAMS TO "+size,_classname);
				
				currentlySwitching = true;
				
				var newStreamName:String;
				if (size == 0) {
					// Small
					newStreamName = this._smilParser.dsi.streams[0].name;
				} else if (size == 1) {
					// Medium
					newStreamName = this._smilParser.dsi.streams[1].name;
				} else {
					size = HIGH_STREAM;
					// Large
						newStreamName = this._smilParser.dsi.streams[2].name;
				}
				
				debug("Going to play: " + newStreamName);
				
				playString = newStreamName;
				
				// Change the buffertime to the loading
					inStream.bufferTime = LOADINGBUFFERTIME;
		
				var nsPlayOptions:NetStreamPlayOptions = new NetStreamPlayOptions(); 
					nsPlayOptions.streamName = newStreamName; 
					nsPlayOptions.transition = NetStreamPlayTransitions.SWITCH; 
				inStream.play2(nsPlayOptions); 
				
				streamName = newStreamName;
				
				currentStreamSize = size;
				bufferEmptyCount = 0;
			}
			
			// Step 8, play the stream
			private function startStream():void {
				if (!alreadyPlaying) {
					alreadyPlaying = true;					
					
					// Create the NetStream
					inStream = new NetStream(nc);
					//pass netStream to mbrManager
					mbrManager.getInstance().addNetStream(inStream,this._smilParser.dsi);
					
					// Listen for status events
					inStream.addEventListener(NetStatusEvent.NET_STATUS, ncStatus);
					
					// The client is this class for metadata and so on
					inStream.client = this;
					
					// Set the bufferTime
					inStream.bufferTime = LOADINGBUFFERTIME;
					
					// 0 indicates at the start
					// -1 indicates till the end
					debug("Playing from playString : " + playString);
					inStream.play(playString, 0, -1);
					inStream.seek(seekInto);

					// Add it to the stage
					remoteVideo = new Video();
					remoteVideo.attachNetStream(inStream);
					videodisplay.addChild(remoteVideo);
					
					// Wait a second and then resize video
					var resizeVideoTimer:Timer = new Timer(500,1);
					resizeVideoTimer.addEventListener(TimerEvent.TIMER,
						function(e:Event):void {
						//	debug("resize video timer fired");
							resizeVideo();
						}
					);
					resizeVideoTimer.start();
					fullscreenImage.visible = true
				}
				else 
				{
					debug("Already Playing");
				}
			}
			
			public function resizeHandler(e:Event):void {
				resizeVideo();
			}
			
			// Step 9
			private function resizeVideo():void {
				// Resize, maintain aspect ratio
				
				if (stage.stageWidth/remoteVideo.width < stage.height/remoteVideo.height) {
					//debug("Width ratio is limiting " + (stage.stageWidth/remoteVideo.width) + " " + (stage.stageHeight/remoteVideo.height)); 
					remoteVideo.width = stage.stageWidth;
					remoteVideo.height = stage.stageWidth/videoWidth * videoHeight; 
				} else {
				//	debug("Height ratio is limiting " + (stage.stageWidth/remoteVideo.width) + " " + (stage.stageHeight/remoteVideo.height)); 
					remoteVideo.width = stage.stageHeight/videoHeight * videoWidth;
					remoteVideo.height = stage.stageHeight;  
				}
				
				
			//	videodisplay.width = remoteVideo.width;
			//	videodisplay.height = remoteVideo.height;
			//	remoteVideo.width = remoteVideo.width-10;
				
				remoteVideo.x = (stage.stageWidth/2)-remoteVideo.width/2;
				remoteVideo.y = ((stage.stageHeight/2) - remoteVideo.height/2);
			/*	
				debug("Stage: " + stage.width + " by " + stage.height);
				debug("Origi: " + videoWidth + " by " + videoHeight);
				debug("Remot: " + remoteVideo.width + " by " + remoteVideo.height);
				debug("Video: " + videodisplay.width + " by " + videodisplay.height);
			*/	
				fullscreenImage.x =  10;
				fullscreenImage.y = stage.stageHeight - fullscreenImage.height;
				if (stage.displayState == StageDisplayState.FULL_SCREEN || stage.displayState == 'fullScreenInteractive') 
				{
					fullscreenImage.y -=  CONTROLBAR_HEIGHT/2;
				}
				else if (stage.displayState == StageDisplayState.NORMAL)
				{
					fullscreenImage.y -=  CONTROLBAR_HEIGHT;	
				}
				
			}			
			
			private function makeFullScreen():void 
			{
				if (stage.displayState == StageDisplayState.FULL_SCREEN || stage.displayState == 'fullScreenInteractive') 
				{
					//stage.fullScreenSourceRect = null; 
					stage.displayState = StageDisplayState.NORMAL;
					debug("Make Normal");	
				}
				else if (stage.displayState == StageDisplayState.NORMAL)
				{
				//	stage.fullScreenSourceRect = new Rectangle(videodisplay.x,videodisplay.y,videodisplay.width,videodisplay.height);
					//stage.displayState = 'fullScreenInteractive';
					stage.displayState = StageDisplayState.FULL_SCREEN;
					debug("Make Fullscreen");	
				}
			}
			
			// Mouse was moved, display fullscreen button
			public function mouseMoveHandler(e:Event):void {
				fullscreenImage.visible = true;
				Mouse.show()
				if (mouseMoveTimer != null && mouseMoveTimer.running) {
					mouseMoveTimer.stop();
				}
				mouseMoveTimer = new Timer(2500,1);
				mouseMoveTimer.addEventListener(TimerEvent.TIMER,mouseMoveTimerFired);
				mouseMoveTimer.start();
			}
			
			// Finished timing mouse, remove full screen button
			public function mouseMoveTimerFired(e:Event):void {
				fullscreenImage.visible = false;	
				Mouse.hide();
			}
			
			
			// Testing Related
			
			// Testing mode timer fired
			private function testTimerFired(e:Event):void {
				if (this._testLocal==true) {
					if (inStream != null) {
						if (!currentlySwitching) {
						//	debug("Time: " + (inStream.time) + " Buffer: " + inStream.bufferLength + 
						//		" Playing: " + currentStreamSize + " FPS: " + inStream.currentFPS);
						} else {
						//	debug("Time: " + (inStream.time) + " Buffer: " + inStream.bufferLength + 
						//		" Switching To: " + currentStreamSize + " FPS: " + inStream.currentFPS);
						}
					}
				}
			}
			
			public function showDebugPanel():void {
			/*	if (debugTextArea.visible == false) {
					debugTextArea.visible = true;
				} else {
					debugTextArea.visible = false;
				}
			*/
				}
			
			public function debug(thetext:String):void {
				if (this._testLocal==true) {
				//	debugTextArea.text += (new Date()).toUTCString() + ":  " + thetext + "\n";
					//trace((new Date()).toString() + ":" + thetext);
				
				}
				tracer.log(thetext,_classname);
			}
			
			public function debugEvent(e:StatusEvent):void {
				debug(e.code);
			}
			
			public function stopStream():void {
				streamCheckTimer.stop();
				inStream.close();	
				
				if (testTimer.running) {
					testTimer.stop();
				}
			} 

			
			// Host Camera
			
			private var hostcam_fmsConn:FMSConnection;
			private var hostcam_ns:FMSStream;
			public var hostcam_vid:Video;
			
			private var hostcam_cpCode:String;
			private var hostcam_streamName:String;
			private var hostcam_streamID:String;
			private var hostcam_bandwidthLimit:Number;
			private var hostcam_qualityLevel:Number;
			private var hostcam_keyFrameInterval:Number;
			private var hostcam_captureWidth:Number;
			private var hostcam_captureHeight:Number;
			private var hostcam_captureFps:Number;
			private var hostcam_favorArea:Boolean;
			private var hostcam_camLoopback:Boolean;
			private var hostcam_micLoopback:Boolean;
			private var hostcam_echoSuppression:Boolean;
			private var hostcam_debugConsole:Boolean;
			private var hostcam_debugAlert:Boolean;
			private var hostcam_bufferMin:Number;
			private var hostcam_bufferMax:Number;
			private var hostcam_micRate:Number;
			private var hostcam_micGain:Number;
			private var hostcam_hostViewerWidth:Number;
			private var hostcam_hostViewerHeight:Number;			
			
			private static const PAUSE_VIDEO:String = "pauseVideo";
			private static const RESTART_VIDEO:String = "restartVideo";
			
			public function showHostCam():void {
				debug("showHostCam");

				// Get the specific flashvars variables for the host cam
				hostcam_cpCode 			= (flashvars.cpCode == undefined) ? "113557" : flashvars.cpCode;
				hostcam_streamName 		= (flashvars.streamName == undefined) ? "none" : flashvars.streamName;
				hostcam_streamID 		= (flashvars.streamID == undefined) ? "45907" : flashvars.streamID;
				
				hostcam_bandwidthLimit 	= (flashvars.bandwidthLimit == undefined) ? 300000 : Number(flashvars.bandwidthLimit);
				
				hostcam_qualityLevel 	= (flashvars.qualityLevel == undefined) ? 0 : Number(flashvars.qualityLevel);
				hostcam_keyFrameInterval= (flashvars.keyFrameInterval == undefined) ? 30 : Number(flashvars.keyFrameInterval);
				hostcam_captureWidth 	= (flashvars.captureWidth == undefined) ? 320 : Number(flashvars.captureWidth);
				hostcam_captureHeight	= (flashvars.captureHeight == undefined) ? 240 : Number(flashvars.captureHeight);
				
				hostcam_captureFps 		= (flashvars.captureFps == undefined) ? 20 : Number(flashvars.captureFps);
				hostcam_bufferMin 		= (flashvars.bufferMin == undefined) ? 2 : Number(flashvars.bufferMin);
				hostcam_bufferMax 		= (flashvars.bufferMax == undefined) ? 15 : Number(flashvars.bufferMax);
				hostcam_micRate 		= (flashvars.micRate == undefined) ? 44 : Number(flashvars.micRate);
				hostcam_micGain 		= (flashvars.micGain == undefined) ? 90 : Number(flashvars.micGain);
				hostcam_hostViewerWidth = (flashvars.hostViewerWidth == undefined) ? 320 : Number(flashvars.hostViewerWidth);
				hostcam_hostViewerHeight= (flashvars.hostViewerHeight == undefined) ? 240 : Number(flashvars.hostViewerHeight);
				
				hostcam_favorArea 		= (flashvars.favorArea 		== "false" || flashvars.favorArea 	  == "0") ? false : true;
				hostcam_camLoopback 	= (flashvars.camLoopback 		== "true"  || flashvars.camLoopback 	  == "1") ? true  : false;
				hostcam_micLoopback 	= (flashvars.micLoopback 		== "true"  || flashvars.micLoopback 	  == "1") ? true  : false;
				hostcam_echoSuppression = (flashvars.echoSuppression 	== "false" || flashvars.echoSuppression == "0") ? false : true;

				debug("hostcam defaults: 113557 none 45907");
				debug("hostcam params: cpCode: " + hostcam_cpCode + " streamName: " + hostcam_streamName + " hostcam_streamID: " + hostcam_streamID);
				
				hostcam_fmsConn = new FMSConnection( hostcam_cpCode, hostcam_streamID, hostcam_streamName);
				hostcam_fmsConn.addEventListener("DEBUG",debugEvent);
				//hostcam_fmsConn.addEventListener( NetEvent.FC_PUBLISH_START, hostcam_createWebcamStream );
				hostcam_fmsConn.addEventListener( NetEvent.NET_CONNECTION_FAILURE, hostcam_connectionFailure );
				hostcam_fmsConn.addEventListener( NetEvent.NET_CONNECTION_SUCCESSFUL, hostcam_connectSuccess);
				hostcam_fmsConn.connect( hostcam_fmsConn.entryPoint );
				
				try {
					ExternalInterface.call("showQaWindow");
					debug("Triggering JS QA Window");
				} catch (err:Error) {
					debug("Error in invoke QA Window");
				}
			}

			private function hostcam_connectionFailure( evt:NetEvent ):void
			{
				debug("connectionFailure is reached");	
			}
			
			private function hostcam_connectSuccess( evt:NetEvent ):void
			{
				debug("connectSuccess is reached");	
				hostcam_createWebcamStream(evt);
			}
				
			private function hostcam_createWebcamStream( evt:NetEvent ):void
			{			
				debug("hostcam_createWebcamStream"); 
				
				hostcam_vid = new Video();
				if (isNaN(hostcam_hostViewerWidth)) {
					hostcam_hostViewerWidth = 320;
				}
				if (isNaN(hostcam_hostViewerHeight)) {
					hostcam_hostViewerHeight = 240;
				}
				hostcam_vid.width = hostcam_hostViewerWidth;
				hostcam_vid.height = hostcam_hostViewerHeight;

				hostcamVideoDisplay.addChild(hostcam_vid);
				hostcamVideoDisplay.visible = true;		
				
				hostcam_ns  = new FMSStream( hostcam_fmsConn.nc, hostcam_vid );
				hostcam_ns.addEventListener("DEBUG",debugEvent);
				debug("added DEBUG listener to hostcam_ns");
				//hostcam_ns.addEventListener(FMSStream.CAMERA_DENIED, notifyCameraDenied);
				//hostcam_ns.addEventListener(FMSStream.CAMERA_ALLOWED, notifyCameraAllowed);
				hostcam_ns.publishStream( hostcam_streamName, hostcam_streamID,
					hostcam_bandwidthLimit, hostcam_qualityLevel, hostcam_keyFrameInterval,
					hostcam_captureWidth, hostcam_captureHeight, hostcam_captureFps, hostcam_favorArea,
					hostcam_camLoopback,
					hostcam_bufferMin,
					hostcam_bufferMax,
					hostcam_echoSuppression,
					hostcam_micLoopback,
					hostcam_micRate,
					hostcam_micGain);											
			}	
			
			public function hideHostCam(evt:MouseEvent=null):void {
				debug("hideHostCam");
				
				hostcam_ns.removeEventListener("DEBUG",debugEvent);
				hostcam_ns.destroy();
				hostcam_ns = null;
				
				hostcam_fmsConn.removeEventListener("DEBUG",debugEvent);
				//hostcam_fmsConn.addEventListener( NetEvent.FC_PUBLISH_START, hostcam_createWebcamStream );
				hostcam_fmsConn.removeEventListener( NetEvent.NET_CONNECTION_FAILURE, hostcam_connectionFailure );
				hostcam_fmsConn.removeEventListener( NetEvent.NET_CONNECTION_SUCCESSFUL, hostcam_connectSuccess);
				hostcam_fmsConn.nc.close();
				hostcam_fmsConn = null;
				
				debug("Hiding the host cam");
				hostcamVideoDisplay.removeChild(hostcam_vid);
				hostcamVideoDisplay.visible = false;
				
				hostcam_vid = null;
			}

			
			
			private var regOffsetX:Number;
			private var regOffsetY:Number;
			private var liveViewerDialogBox:MovieClip;
			private var boxAlpha:Number;
			private var borderSize:Number;
			private var _currentErrorCode:String = "";
			
			
			


			
			private function dragIt (evt:MouseEvent):void {
				debug("dragIt");
				var thisClip:MovieClip = MovieClip(evt.currentTarget);
				debug("Got to dragit for boxClip");
				//thisClip.addEventListener(MouseEvent.ROLL_OVER, keepDragging, false, 0, true);
				thisClip.addEventListener(MouseEvent.ROLL_OUT, stopDragging, false, 0, true);
				// Keep the box within the stage area - accounting for both the offset and width of the box
				thisClip.startDrag(false, new Rectangle (-regOffsetX, -regOffsetY, 
					stage.stageWidth + regOffsetX*2, stage.stageHeight+regOffsetY*2));
			}
			
			private function stopDragging (evt:MouseEvent):void {
				debug("stopDragging");
				debug("Got to stopDragging");
				var thisClip:MovieClip = MovieClip(evt.currentTarget);
				thisClip.stopDrag();
			}
			
			private function makeDialogBox (closeCallback:Function,
											posX:Number, posY:Number,
											border:Number,
											w:Number, h:Number, 
													  color:uint, alpha:Number):MovieClip {
				debug("makeDialogBox");
				//var holderClip:MovieClip = new MovieClip();		// Needed for offset for dragging operation
				var boxClip:MovieClip = new MovieClip();
				var boxWidth:Number  = w + 2 * border;
				var boxHeight:Number = h + 2 * border;
				boxClip.mouseChildren = true;
				boxClip.mouseEnabled = true;
				// Offset overything so the mouse is centered when dragging the box
				regOffsetX = -(w/2 + border);
				regOffsetY = -(h/2 + border);
				//boxClip.transform.matrix = new Matrix(1, 0, 0, 1, regOffsetX, regOffsetY);
				boxClip.graphics.beginFill(color, alpha);	// black,  with % alpha
				boxClip.graphics.moveTo (regOffsetX, 			regOffsetY);
				boxClip.graphics.lineTo (regOffsetX+boxWidth, 	regOffsetY);
				boxClip.graphics.lineTo (regOffsetX+boxWidth, 	regOffsetY+boxHeight);
				boxClip.graphics.lineTo (regOffsetX, 			regOffsetY+boxHeight);
				boxClip.graphics.lineTo (regOffsetX, 			regOffsetY);
				boxClip.graphics.endFill();
				boxClip.x = posX - border + regOffsetX;
				boxClip.y = posY - border + regOffsetY;
				
				boxClip.addEventListener(MouseEvent.MOUSE_DOWN, dragIt, false, 0, true); //Use a weak reference, 'cause I'm lazy
				boxClip.addEventListener(MouseEvent.MOUSE_UP, stopDragging, false, 0, true);
				boxClip.name += "_makeDialogBox";
				
				return boxClip;
			}
			
			public function camViewerStart():void {
				debug("camViewerStart");
				//debug("AkamaiMultiPlayerExample camViewerStart");
				if (liveViewerSwf != null) {
					//debug("AkamaiMultiPlayerExample camViewerStart");
					hideLiveViewer( null, false );
				}
				showLiveViewer();
			}
			
			public function showLiveViewer():void {
				debug("showLiveViewer");
				var swfWidth:Number = Number(loaderInfo.parameters.viewerWidth);
				var swfHeight:Number = Number(loaderInfo.parameters.viewerHeight);
				var posX:Number = Number(loaderInfo.parameters.viewerPosX);
				var posY:Number = Number(loaderInfo.parameters.viewerPosY);
				
				debug("Got to showLiveViewer in AS");
				/*
				swfWidth  = isNaN(swfWidth)  ? 275 : swfWidth,
				swfHeight = isNaN(swfHeight) ? 205 : swfHeight
				*/
				swfWidth  = isNaN(swfWidth)  ? 320 : swfWidth,
				swfHeight = isNaN(swfHeight) ? 240 : swfHeight
				
				if (!liveViewerSwf) {
					//debug("LiveViewerUrl looks good: " + liveViewerUrl);
					//debug("LiveViewerUrl width and height: " + swfWidth + ":" + swfHeight);
					
					if (isNaN(posX)) {
						//posX = this.stage.stageWidth - swfWidth - borderSize*2;
						posX = 19;
						//debug("posX is NaN, setting to:" + posX);
					}
					
					if (isNaN(posY)) {
						posY = 19;
					} 
					// Compensate for other offsets, so that the x,y specified by user is position of upper-left corner
					posX += 3*borderSize + swfWidth;
					posY += 3*borderSize + swfHeight;
					var showViewer:Boolean = (loaderInfo.parameters.maskViewer == undefined) ? true : loaderInfo.parameters.maskViewer;
					
					var swfName:String = (loaderInfo.parameters.liveViewerUrl == undefined) ? "/flash/LiveStream.swf" : "/flash/LiveStream_v" + loaderInfo.parameters.liveViewerUrl + ".swf";
						swfName = "/flash/LiveStream_testing.swf";
					// We basically need to recreate this every time.
					liveViewerSwf = new LoadExternalSwf(swfName, 
						swfWidth, swfHeight,
						0, 0,
						showViewer);
					//debug("LiveViewerUrl position: " + posX + ":" + posY);
					
					//liveViewerSwf.x = /* -borderSize */ - swfWidth/2;
					//liveViewerSwf.y = /* -borderSize */ - swfHeight/2;
					liveViewerSwf.x = 0;
					liveViewerSwf.y = 0;
					//liveViewerSwf.width = swfWidth;
					//liveViewerSwf.height = swfHeight;
					//debug("LiveViewerUrl x,y: " + liveViewerSwf.x + ":" + liveViewerSwf.y);
					
					if (!liveViewerDialogBox) {
						liveViewerDialogBox = makeDialogBox(hideLiveViewer, posX, posY, borderSize, 
							swfWidth, swfHeight, 0x000000, boxAlpha);
					}
					// The entire viewer is destroyed when it is removed from the stage
					// So we need to recreate it entirely.
					liveViewerDialogBox.addChild(liveViewerSwf);
					liveViewerDialogBox.name = "liveViewerDialogBox";
					stage.addChild(liveViewerDialogBox);
					liveViewerSwf.addEventListener("Host_Cam_Timeout", destroyLiveViewer);
					
				} else {
					//debug("LiveViewerUrl already loaded: " + liveViewerUrl);
				}
			}
			
			public function hideLiveViewer(evt:MouseEvent=null,hideWindow:Boolean=true):void {
				debug("hideLiveViewer");
				if (liveViewerDialogBox) {
					try {
						debug("AkamaiMultiplayerExample Hiding liveViewerDialogBox");
						stage.removeChild(liveViewerDialogBox);
					} catch (err:Error) {
						//debug("Error in Hiding Live Viewer");
					}
				}
				//debug("Got to hideLiveViewer in AS");
				if (liveViewerSwf) {
					debug("AkamaiMultiplayerExample Hiding live video");
					// This destroys the object, as it mostly destroys itself when removed from stage
					// FIXME - need to verify this works as intended.
					if (hideWindow) {
						try {
							ExternalInterface.call("hideQaWindow");
						} catch (err:Error) {
							debug("Error in invoke QA Window");
						}
					}
					try {
						liveViewerSwf.removeEventListener("Host_Cam_Timeout", destroyLiveViewer);
						liveViewerDialogBox.removeChild(liveViewerSwf);
						liveViewerSwf = null;
					} catch (err:Error) {
						debug("Error in Hiding Live Viewer");
					}
					
				} else {
					//debug("There was no live viewer to hide");
				}
			}
			
			public function destroyLiveViewer(evt:Event=null):void {
				debug("destroyLiveViewer");
				
				if (liveViewerDialogBox) {
					try {
						debug("Hiding liveViewerDialogBox");
						stage.removeChild(liveViewerDialogBox);
					} catch (err:Error) {
						debug("Error in Hiding Live Viewer");
					}
				}
				//debug("Got to hideLiveViewer in AS");
				if (liveViewerSwf) {
					debug("Hiding live video");
					try {
						liveViewerSwf.removeEventListener("Host_Cam_Timeout", destroyLiveViewer);
						liveViewerDialogBox.removeChild(liveViewerSwf);
						liveViewerSwf = null;
					} catch (err:Error) {
						debug("Error in Hiding Live Viewer");
					}
					
				} else {
					//debug("There was no live viewer to hide");
				}
			}
			
			protected function onHeartAttack(evt:constellationEvent):void
			{
				var typeOfAttack:String = evt.data as String;
				var userMessage:String = ExternalConfig.getInstance().heartbeatFailMessage
				
				if(typeOfAttack.toLowerCase()==heartbeatController.RESPONSE_ATTACK.toLowerCase()){
					this._currentErrorCode = errorConfig.heartbeat_FailedResponse_ErrorCode

				}else if(typeOfAttack.toLowerCase()==heartbeatController.SERVER_REJECT_ATTACK.toLowerCase()){
					this._currentErrorCode = errorConfig.heartbeat_ServerReject_ErrorCode;

				}else if(typeOfAttack.toLowerCase()==heartbeatController.SKIPPED_BEATS_ATTACK.toLowerCase()){
					this._currentErrorCode = errorConfig.heartbeat_SkippedBeats_ErrorCode;

				}else{
					userMessage = ExternalConfig.getInstance().heartbeatFailMessage_unknown;
				}
				if(this._currentErrorCode==null||this._currentErrorCode!=""){
					userMessage+=this._currentErrorCode
				}
				trace("HEART ATTACK "+userMessage);
				this.disconnectStream();
				this.showHeartAttackView(userMessage);
			}
			
			private function showHeartAttackView(message:String=null):void
			{
				/*var blackDisplay:Sprite = new Sprite();
					blackDisplay.graphics.beginFill(0x000000,0.80);	
					blackDisplay.graphics.drawRect(20,20,this.stage.stageWidth-40,this.stage.stageHeight-40);
					this.addChildAt(blackDisplay,stage.numChildren-1);
				*/	
				if(message==null){
					displayMessage(ExternalConfig.getInstance().heartbeatFailMessage_unknown,false);
				}else{
					displayMessage(message,false);
				}
				this.videodisplay.alpha = .25;
			}
			private function replaceSpacesWithPlus (inString:String):String {
				var SPACE:String = " ";
				var PLUS:String = "+";
				return replace (inString, SPACE, PLUS);
			}
			
			private  function replace (inString:String, replaceThis:String, withThis:String):String {
				var tmp:String = (inString.split(replaceThis)).join(withThis);
				return tmp;
			} 
			
			
			protected function onSMIL_Malformed(event:Event):void
			{
				this._currentErrorCode = errorConfig.stream_smilMalformed;
				this.displayMessage(ExternalConfig.getInstance().defaultErrorMessage+errorConfig.stream_smilMalformed);
			}
			
			protected function onIncrementTimeStamp(event:TimerEvent):void
			{
				if(this._timeStampServer==0){
					this._timeStampServer = ExternalConfig.getInstance().initTimeStamp;
				}
				this._timeStampServer +=TIMESTAMP_INTERVAL
				tracer.log("timestamp increment "+this._timeStampServer,_classname);
			}
			
			private function initExternalInterface():void
			{
				if (ExternalInterface.available) {
					ExternalInterface.addCallback("setVolume", setVolume);
					ExternalInterface.addCallback("showHostCam", showHostCam);
					ExternalInterface.addCallback("hideHostCam", hideHostCam);
					ExternalInterface.addCallback("showLiveViewer", showLiveViewer);
					ExternalInterface.addCallback("hideLiveViewer", hideLiveViewer);
					ExternalInterface.addCallback("camViewerStart", camViewerStart);
					debug("setup External Interface");
				} else {
					debug("External Interface not available");
				}
			}
			// Stream Check Magic..  Periodic checking buffer and bandwidth
			/* not used but kept for reference
			private function streamCheckTimerFired(e:Event):void {
				
				debug("*********************************************   Timer Fired stream complete "+streamComplete);
				
				if (!streamComplete) {
					
					if (inStream != null && !currentlySwitching) {
						debug("Buffer: len: " + inStream.bufferLength+"  max time "+inStream.bufferTime);
						
						if (lastInStreamTime < inStream.time) {
							lastInStreamTime = inStream.time;
						}
						
						if (inStream.bufferTime == LOADINGBUFFERTIME && inStream.bufferLength >= LOADINGBUFFERTIME) {
							debug("Increasing Buffer to playing buffer");
							inStream.bufferTime = PLAYINGINGBUFFERTIME;
							bufferHighCount = 0;
							bufferLowCount = 0;
						} else if (inStream.bufferLength >= PLAYINGINGBUFFERTIME) {
							debug("Buffer High");
							bufferHighCount++;
							if (bufferHighCount >= BUFFERHIGHCOUNTTHRESHOLD) {
								debug("Buffer high enough for long enough");
								if (currentStreamSize < MAXSTREAMSIZE) {
									if (CHECKBANDWIDTH) {
										debug("Increasing stream, Checking bandwidth");
										laterCheckBandwidth = true;
										nc.call("checkBandwidth", null);
									} else {
										swapStream(currentStreamSize+1);
									}
									
								} else {
									debug("Already at largest stream");
								}
								
								bufferHighCount = 0;
							}
							bufferLowCount = 0;
							bufferEmptyCount = 0;
						} else if (inStream.bufferLength <= .1) {
							debug("Buffer Empty at " + inStream.bufferLength);
							bufferEmptyCount++;
							if (bufferEmptyCount >= BUFFEREMPTYCOUNTTHRESHOLD) {
								if (currentStreamSize > 0) {
									debug("Lowering stream");
									swapStream(currentStreamSize-1);
								} else {
									// Pop-up Issue here
									debug("**************************");
									debug("Already at smallest stream 1 - checking BW");
									if (CHECKBANDWIDTH) {
										laterCheckBandwidth = true;
										nc.call("checkBandwidth", null);
									}
									//displayBufferingMessage();
									
								}
								bufferEmptyCount = 0;
							}
							bufferHighCount = 0;
						}
							//else if (inStream.bufferLength >= lastBufferLength) {
							//debug("Buffer low but constant or increasing 1");
							//bufferHighCount = 0;
							//bufferLowCount = 0;
							//bufferEmptyCount = 0;
						} else if (inStream.bufferTime == PLAYINGINGBUFFERTIME && 
							inStream.bufferLength < PLAYINGINGBUFFERTIME) {
							debug("Buffer low and not increasing 2");
							
							if (bufferLowCount >= BUFFERLOWCOUNTTHRESHOLD) {
								debug("Buffer low enough for long enough 3");
								
								if (currentStreamSize > 0) {
									debug("Decreasing stream ");
									inStream.bufferTime = LOADINGBUFFERTIME;
									//		swapStream(currentStreamSize-1);
								} else {
									
									// Pop-up Issue here
									debug("**************************");
									inStream.bufferTime = LOADINGBUFFERTIME;
									debug("Already at smallest stream 2 - checking BW");
									if (CHECKBANDWIDTH) {
										laterCheckBandwidth = true;
										nc.call("checkBandwidth", null);
									}
									
									//displayNotEnoughBandwidthMessage();
								}
							}
							bufferLowCount++;
							
						}
						lastBufferLength = inStream.bufferLength;
						
						
						// FPS Checking
						if (inStream.currentFPS == 0 && inStream.bufferLength >= LOADINGBUFFERTIME) {
							debug("0 FPS but there is a buffer so PLAY");
							inStream.bufferTime = LOADINGBUFFERTIME;
							inStream.resume();
							//swapStream(currentStreamSize);
						} else if (inStream.currentFPS == 0 && inStream.bufferLength < LOADINGBUFFERTIME) {
							fpsZeroCount++;
							if (fpsZeroCount >= FPSZEROCOUNTTHRESHOLD)
							{
								displayBufferingMessage();
								
								if (currentStreamSize > 0) {
									debug("Decreasing stream");
									swapStream(currentStreamSize-1);
								} else {
									
									// Pop-up Issue here
									inStream.bufferTime = LOADINGBUFFERTIME;
									debug("**************************");
									debug("Already at smallest stream 3 ");
									if (CHECKBANDWIDTH) {
										laterCheckBandwidth = true;
										nc.call("checkBandwidth", null);
									}
								}
							}
						} else {
							fpsZeroCount = 0;
						}
					}
				}
				else
				{
					debug("Stream Complete");
				}
			}
			*/
			
			
			protected function onAsyncError(event:AsyncErrorEvent):void
			{
				// TODO Auto-generated method stub
				
			}
			
		]]>			
	</mx:Script>

	<mx:VideoDisplay x="6" y="0" id="videodisplay" width="100%" height="100%" maintainAspectRatio="true"  />

	<mx:VideoDisplay x="0" y="0" id="hostcamVideoDisplay" visible="false" width="320" height="240" opaqueBackground="#505050" />
	
	<mx:Text x="0" y="0" id="messages" text="No Messages" width="525" visible="false"  color="#FFFFFF" fontSize="16" opaqueBackground="#505050" textAlign="center" paddingBottom="250" />
	
	<!--<mx:Button x="25" y="546" label="Small" id="smallstream" click="swapStream(0)" visible="false" />
	<mx:Button x="100" y="546" label="Medium" id="mediumstream" click="swapStream(1)" visible="false" />
	<mx:Button x="175" y="546" label="Large" id="largestream" click="swapStream(2)" visible="false" />
	<mx:Button x="250" y="546" label="Stop" id="stopstream" click="stopStream()" visible="false" />

	<mx:Button label="Debug" id="debugButton" click="showDebugPanel()" x="500" y="545" visible="false" />
	
	<mx:TextArea x="0" y="0" id="debugTextArea" width="500" height="300" borderVisible="true" text="Debug Panel" wordWrap="true" visible="false" />
	-->
	
	<mx:Image id="fullscreenImage" source="@Embed(source='constellation_player_fullscreen.png')" y="0" x="0" click="makeFullScreen()" />
	
</mx:Application>
